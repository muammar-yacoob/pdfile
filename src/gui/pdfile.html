<!DOCTYPE html>
<html data-pdfile data-width="700" data-height="590">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    <title>PDFile - PDF Utility Toolkit</title>
    <link rel="icon" href="img/logo.ico">
    <link rel="stylesheet" href="/css/theme.css">
    <link rel="stylesheet" href="/css/flatpickr.min.css">
    <link rel="stylesheet" href="/css/pickr.min.css">
    <script src="/js/lucide.min.js"></script>
    <script src="/js/pdf.min.js"></script>
    <script src="/js/flatpickr.min.js"></script>
    <script src="/js/pickr.min.js"></script>
    <style>
        * { box-sizing: border-box; }

        /* Scrollbar Styling */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        ::-webkit-scrollbar-track {
            background: var(--bg);
        }

        ::-webkit-scrollbar-thumb {
            background: #7fa5df;
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #a3b8d9;
        }

        .app {
            display: flex;
            flex-direction: column;
            height: 100vh;
            padding: 10px;
            gap: 8px;
        }

        .header {
            display: flex;
            align-items: center;
            gap: 8px;
            padding-bottom: 8px;
            border-bottom: 1px solid var(--brd);
            flex-shrink: 0;
        }

        .header b {
            font-size: 14px;
            background: linear-gradient(135deg, #7fa5df, #a3b8d9);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .header span {
            font-size: 11px;
            color: var(--txt3);
            flex: 1;
        }

        .header-btn {
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: transparent;
            border: 1px solid var(--brd);
            border-radius: 6px;
            color: var(--txt3);
            cursor: pointer;
            transition: all 0.2s;
            position: relative;
        }

        .header-btn:hover {
            background: var(--bg2);
            border-color: #7fa5df;
            color: #7fa5df;
        }

        .header-btn:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }

        /* Dark mode for flatpickr calendar */
        .flatpickr-calendar {
            background: var(--bg2) !important;
            border: 1px solid var(--brd) !important;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4) !important;
            max-width: 280px !important;
            font-size: 13px !important;
        }

        .flatpickr-day {
            max-width: 35px !important;
            height: 35px !important;
            line-height: 35px !important;
        }

        .flatpickr-months {
            background: var(--bg) !important;
        }

        .flatpickr-month, .flatpickr-current-month .flatpickr-monthDropdown-months {
            color: var(--txt) !important;
        }

        .flatpickr-weekdays {
            background: var(--bg) !important;
        }

        .flatpickr-weekday {
            color: var(--txt3) !important;
        }

        .flatpickr-day {
            color: var(--txt) !important;
        }

        .flatpickr-day:hover, .flatpickr-day.selected {
            background: #7fa5df !important;
            border-color: #7fa5df !important;
        }

        .flatpickr-day.today {
            border-color: #7fa5df !important;
        }

        /* Dark mode for Pickr color picker */
        .pcr-app {
            background: var(--bg2) !important;
            border: 1px solid var(--brd) !important;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4) !important;
        }

        .pcr-app .pcr-interaction .pcr-result,
        .pcr-app .pcr-interaction input {
            background: var(--bg) !important;
            color: var(--txt) !important;
            border-color: var(--brd) !important;
        }

        .pcr-app .pcr-interaction .pcr-save {
            background: #7fa5df !important;
        }

        .pcr-app .pcr-interaction .pcr-save:hover {
            background: #6a8fc7 !important;
        }

        .pcr-app .pcr-interaction .pcr-clear,
        .pcr-app .pcr-interaction .pcr-cancel {
            background: #f44250 !important;
        }

        .pcr-app .pcr-swatches > button {
            border: 1px solid var(--brd) !important;
        }

        /* Smaller color picker button */
        .pickr {
            width: 24px !important;
            height: 24px !important;
        }

        .pickr .pcr-button {
            width: 24px !important;
            height: 24px !important;
            border-radius: 4px !important;
            border: 1px solid var(--brd) !important;
        }

        /* Main 3-column layout */
        .main {
            display: flex;
            flex: 1;
            gap: 8px;
            overflow: hidden;
        }

        /* Left: Page Thumbnails */
        .thumbnails-panel {
            width: 160px;
            background: var(--bg2);
            border-radius: 6px;
            border: 1px solid var(--brd);
            display: flex;
            flex-direction: column;
            overflow: hidden;
            transition: width 0.3s ease;
        }

        .thumbnails-panel.collapsed {
            width: 40px;
        }

        .thumbnails-panel.collapsed .thumbnails-list {
            display: none;
        }

        .thumbnails-header {
            padding: 6px 8px;
            border-bottom: 1px solid var(--brd);
            font-size: 10px;
            font-weight: 600;
            color: var(--txt2);
            text-align: center;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .thumbnails-header .collapse-btn {
            width: 20px;
            height: 20px;
            background: transparent;
            border: none;
            cursor: pointer;
            padding: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--txt3);
            transition: color 0.2s;
        }

        .thumbnails-header .collapse-btn:hover {
            color: #7fa5df;
        }

        .thumbnails-panel.collapsed .thumbnails-header {
            flex-direction: column;
            gap: 4px;
        }

        .thumbnails-panel.collapsed .thumbnails-header span {
            writing-mode: vertical-rl;
            transform: rotate(180deg);
        }

        /* Page Actions Toolbar */
        .page-actions-toolbar {
            display: flex;
            align-items: center;
            gap: 4px;
            padding: 6px;
            border-bottom: 1px solid var(--brd);
            background: var(--bg);
        }

        .page-action-btn {
            width: 28px;
            height: 28px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: transparent;
            border: 1px solid var(--brd);
            border-radius: 4px;
            color: var(--txt2);
            cursor: pointer;
            transition: all 0.2s;
        }

        .page-action-btn:hover:not(:disabled) {
            background: var(--bg2);
            border-color: #7fa5df;
            color: #7fa5df;
        }

        .page-action-btn:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }

        /* Arrow buttons - blue when enabled */
        .page-action-btn:not(:disabled).arrow-btn {
            color: #7fa5df;
            border-color: #7fa5df;
        }

        .page-action-btn:not(:disabled).arrow-btn:hover {
            background: rgba(127, 165, 223, 0.1);
            border-color: #a3b8d9;
            color: #a3b8d9;
        }

        /* Trash button - always dark red */
        .page-action-btn.delete-btn {
            color: #dc3545;
            border-color: #dc3545;
        }

        .page-action-btn.delete-btn:hover:not(:disabled) {
            background: rgba(220, 53, 69, 0.1);
            border-color: #c82333;
            color: #c82333;
        }

        .page-action-btn.delete-btn:disabled {
            color: #dc3545;
            border-color: #dc3545;
            opacity: 0.3;
        }

        .thumbnails-list {
            flex: 1;
            overflow-y: auto;
            padding: 6px;
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .thumbnail-item {
            background: var(--bg);
            border: 2px solid var(--brd);
            border-radius: 4px;
            cursor: grab;
            position: relative;
            transition: all 0.2s;
            user-select: none;
        }


        .thumbnail-item:hover {
            border-color: #7fa5df;
            transform: translateX(2px);
        }

        .thumbnail-item.dragging {
            opacity: 0.5;
            cursor: grabbing;
        }

        .thumbnail-item.dragover {
            border-color: #7fa5df;
            background: rgba(127, 165, 223, 0.1);
        }

        .thumbnail-canvas {
            width: 100%;
            height: auto;
            display: block;
            border-radius: 3px;
        }

        .thumbnail-number {
            position: absolute;
            top: 4px;
            left: 4px;
            background: rgba(0, 0, 0, 0.7);
            color: #fff;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 10px;
            font-weight: 600;
        }

        .thumbnail-item.selected {
            border: 3px solid #7fa5df !important;
            background: rgba(127, 165, 223, 0.15);
            box-shadow: 0 0 12px rgba(127, 165, 223, 0.5);
            position: relative;
        }

        .thumbnail-item.selected::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 32px;
            height: 32px;
            background: #7fa5df;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            pointer-events: none;
            z-index: 10;
        }

        .thumbnail-item.selected .thumbnail-checkmark {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 32px;
            height: 32px;
            background: #7fa5df;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            pointer-events: none;
            z-index: 10;
            color: white;
        }

        /* Center: PDF Preview */
        .preview-panel {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 8px;
            min-width: 400px;
        }

        .preview-area {
            flex: 1;
            background: var(--bg2);
            border-radius: 6px;
            border: 1px solid var(--brd);
            overflow: auto;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .preview-area::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }
        .preview-area::-webkit-scrollbar-track {
            background: var(--bg);
        }
        .preview-area::-webkit-scrollbar-thumb {
            background: #7fa5df;
            border-radius: 4px;
        }
        .preview-area::-webkit-scrollbar-thumb:hover {
            background: #a3b8d9;
        }

        .preview-area::before {
            content: '';
            position: absolute;
            inset: 0;
            background: repeating-conic-gradient(#1a1a1d 0% 25%, #222 0% 50%) 50%/16px 16px;
            z-index: 0;
        }

        .canvas-wrapper {
            position: relative;
            display: inline-block;
            z-index: 1;
        }

        .preview-area canvas {
            display: block;
            max-width: 100%;
            max-height: 100%;
            background: #fff;
        }

        .preview-area .placeholder {
            position: relative;
            z-index: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 12px;
            color: var(--txt3);
            font-size: 12px;
        }

        .load-btn {
            padding: 8px 16px;
            font-size: 11px;
            background: var(--bg2);
            border: 1px dashed var(--brd);
            border-radius: 6px;
            color: var(--txt3);
            cursor: pointer;
            transition: all 0.2s;
        }

        .load-btn:hover {
            border-color: #7fa5df;
            color: #7fa5df;
        }

        /* Overlay gizmo */
        .overlay-gizmo {
            position: absolute;
            border: 2px dotted #7fa5df;
            background: rgba(127, 165, 223, 0.1);
            cursor: move;
            z-index: 10;
            min-width: 80px;
            min-height: 40px;
            padding: 20px 4px 4px 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            user-select: none;
        }

        .overlay-gizmo img {
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
            pointer-events: none;
        }

        .overlay-gizmo-text {
            font-size: 10px;
            color: #7fa5df;
            text-align: center;
            word-break: break-word;
            padding: 4px;
        }

        .overlay-gizmo:hover {
            background: rgba(127, 165, 223, 0.2);
            border-style: dashed;
            border-color: #a3b8d9;
        }

        .overlay-gizmo-handle {
            position: absolute;
            width: 12px;
            height: 12px;
            background: #7fa5df;
            border: 2px solid #fff;
            border-radius: 50%;
            cursor: nwse-resize;
            bottom: -6px;
            right: -6px;
            z-index: 10;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s;
        }

        .overlay-gizmo:hover .overlay-gizmo-handle {
            opacity: 1;
            pointer-events: auto;
        }

        .overlay-gizmo-rotate {
            position: absolute;
            bottom: -11px;
            left: -11px;
            width: 22px;
            height: 22px;
            background: #7fa5df;
            border: 2px solid #fff;
            border-radius: 50%;
            cursor: grab;
            z-index: 10;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            color: #000;
            font-weight: bold;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s;
        }

        .overlay-gizmo:hover .overlay-gizmo-rotate {
            opacity: 1;
            pointer-events: auto;
        }

        .overlay-gizmo-rotate:active {
            cursor: grabbing;
        }

        .overlay-gizmo-label {
            display: none; /* Hidden - unnecessary */
        }

        .overlay-gizmo-delete {
            position: absolute;
            top: -10px;
            right: -10px;
            width: 20px;
            height: 20px;
            background: #ff4444;
            border: 2px solid #1a1a1d;
            border-radius: 50%;
            color: white;
            font-size: 12px;
            font-weight: bold;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0;
            line-height: 1;
            opacity: 1;
            pointer-events: auto;
            transition: all 0.2s;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        .overlay-gizmo-delete:hover {
            background: #ff0000;
            transform: scale(1.1);
        }

        .overlay-gizmo-transparent {
            position: absolute;
            top: -22px;
            right: 22px;
            width: 18px;
            height: 18px;
            background: var(--bg2);
            border: 1px solid var(--brd);
            border-radius: 3px;
            color: var(--txt3);
            font-size: 10px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0;
            opacity: 0;
            pointer-events: none;
            transition: all 0.2s;
        }

        .overlay-gizmo:hover .overlay-gizmo-transparent {
            opacity: 1;
            pointer-events: auto;
        }

        .overlay-gizmo-transparent.active {
            background: #7fa5df;
            border-color: #7fa5df;
            color: #000;
        }

        .overlay-gizmo-transparent:hover {
            background: #7fa5df;
            border-color: #7fa5df;
            color: #000;
        }

        .overlay-gizmo.selected {
            border: 2px solid #7fa5df !important;
            box-shadow: 0 0 8px rgba(127, 165, 223, 0.6);
        }

        /* Layers List */
        .layer-item {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 6px 8px;
            background: var(--bg);
            border: 1px solid var(--brd);
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 11px;
        }

        .layer-item:hover {
            background: var(--bg3);
            border-color: #7fa5df;
        }

        .layer-item.selected {
            background: rgba(127, 165, 223, 0.15);
            border-color: #7fa5df;
        }

        .layer-icon {
            color: var(--txt3);
            flex-shrink: 0;
        }

        .layer-name {
            flex: 1;
            color: var(--txt);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .layer-controls {
            display: flex;
            gap: 2px;
            flex-shrink: 0;
        }

        .layer-btn {
            width: 18px;
            height: 18px;
            background: transparent;
            border: 1px solid var(--brd);
            border-radius: 3px;
            color: var(--txt3);
            font-size: 10px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0;
            transition: all 0.2s;
        }

        .layer-btn:hover {
            background: var(--bg3);
            border-color: #7fa5df;
            color: #7fa5df;
        }

        .layer-btn:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }

        /* Right: Tools */
        .tools-panel {
            width: 240px;
            display: flex;
            flex-direction: column;
            gap: 6px;
            overflow-y: auto;
        }

        .tool {
            background: var(--bg2);
            border: 1px solid var(--brd);
            border-radius: 6px;
            overflow: hidden;
        }

        .tool.active {
            border-color: #7fa5df;
        }

        .tool-header {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 7px 8px;
            user-select: none;
        }

        .tool-header .icon {
            width: 15px;
            height: 15px;
            opacity: 0.6;
            color: var(--txt2);
        }

        .tool.active .tool-header .icon {
            opacity: 1;
            color: #7fa5df;
        }

        .tool-header .name {
            flex: 1;
            font-size: 11px;
            color: var(--txt2);
        }

        .tool.active .tool-header .name {
            color: var(--txt);
            font-weight: 500;
        }

        .tool-body {
            display: none;
            padding: 8px;
            border-top: 1px solid var(--brd);
        }

        .tool.active .tool-body {
            display: block;
        }

        .tool-desc {
            font-size: 10px;
            color: var(--txt3);
            margin-bottom: 10px;
        }

        .tool-btn {
            width: 100%;
            padding: 6px 10px;
            font-size: 10px;
            background: #7fa5df;
            border: none;
            border-radius: 4px;
            color: #000;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            margin-top: 6px;
        }

        .tool-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        @keyframes spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }

        .tool-btn:hover {
            background: #a3b8d9;
        }

        .tool-btn-secondary {
            background: var(--bg3);
            color: var(--txt2);
            border: 1px solid var(--brd);
        }

        .tool-btn-secondary:hover {
            background: var(--bg2);
            border-color: #7fa5df;
            color: var(--txt);
        }

        /* Form elements */
        .form-group {
            margin-bottom: 8px;
        }

        .form-label {
            display: block;
            font-size: 9px;
            color: var(--txt2);
            margin-bottom: 3px;
            font-weight: 500;
        }

        .form-input,
        .form-select {
            width: 100%;
            padding: 5px 7px;
            background: var(--bg);
            border: 1px solid var(--brd);
            border-radius: 4px;
            color: var(--txt);
            font-size: 11px;
        }

        .form-input:focus,
        .form-select:focus {
            outline: none;
            border-color: #7fa5df;
        }

        .color-picker {
            width: 100%;
            height: 32px;
            cursor: pointer;
            border-radius: 4px;
            border: 1px solid var(--brd);
        }

        /* Toggle buttons */
        .toggle-btn {
            padding: 5px 10px;
            font-size: 10px;
            background: var(--bg);
            border: 1px solid var(--brd);
            border-radius: 4px;
            cursor: pointer;
            color: var(--txt2);
            transition: all 0.2s;
            font-weight: 500;
            white-space: nowrap;
        }

        .toggle-btn:hover {
            background: var(--bg2);
            border-color: #7fa5df;
        }

        .toggle-btn.active {
            background: #7fa5df;
            color: #000;
            border-color: #7fa5df;
            font-weight: 600;
        }

        /* Toggle Switch */
        .switch {
            position: relative;
            display: inline-block;
            width: 40px;
            height: 20px;
        }

        .switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: var(--bg2);
            border: 1px solid var(--brd);
            transition: 0.3s;
            border-radius: 20px;
        }

        .slider:before {
            position: absolute;
            content: "";
            height: 14px;
            width: 14px;
            left: 2px;
            bottom: 2px;
            background-color: var(--txt3);
            transition: 0.3s;
            border-radius: 50%;
        }

        input:checked + .slider {
            background-color: #7fa5df;
            border-color: #7fa5df;
        }

        input:checked + .slider:before {
            transform: translateX(20px);
            background-color: #fff;
        }

        /* Compact toggle button (Trans) */
        #transparentBtn {
            min-width: 50px;
            padding: 5px 8px;
            font-size: 9px;
            font-weight: 700;
            letter-spacing: 0.3px;
        }


        /* Recent images list */
        .recent-image-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 6px;
            background: var(--bg);
            border: 1px solid var(--brd);
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .recent-image-item:hover {
            background: var(--bg2);
            border-color: #7fa5df;
        }

        .recent-image-item img {
            width: 40px;
            height: 40px;
            object-fit: cover;
            border-radius: 3px;
            border: 1px solid var(--brd);
        }

        .recent-image-item .name {
            flex: 1;
            font-size: 10px;
            color: var(--txt2);
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .recent-image-item .insert-btn {
            padding: 4px 8px;
            font-size: 9px;
            background: #7fa5df;
            border: none;
            border-radius: 3px;
            color: #000;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }

        .recent-image-item .insert-btn:hover {
            background: #a3b8d9;
        }

        /* Color picker with label */
        .color-input-group {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .color-input-group .pickr {
            flex-shrink: 0;
        }

        .color-input-group label {
            font-size: 10px;
            color: var(--txt2);
            font-weight: 500;
        }

        /* Tabs */
        .tabs {
            display: flex;
            gap: 4px;
            margin-bottom: 10px;
        }

        .tab {
            flex: 1;
            padding: 6px;
            font-size: 10px;
            background: var(--bg);
            border: 1px solid var(--brd);
            border-radius: 4px;
            cursor: pointer;
            text-align: center;
            color: var(--txt3);
            transition: all 0.2s;
        }

        .tab.active {
            background: #7fa5df;
            color: #000;
            border-color: #7fa5df;
            font-weight: 600;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        /* Custom Modal */
        .modal-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.7);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 9999;
            backdrop-filter: blur(4px);
            animation: fadeIn 0.2s ease-out;
        }

        .modal-overlay.active {
            display: flex;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        @keyframes slideIn {
            from { transform: translateY(-20px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }

        .modal {
            background: var(--bg);
            border: 1px solid var(--brd);
            border-radius: 8px;
            padding: 20px;
            min-width: 320px;
            max-width: 480px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
            animation: slideIn 0.3s ease-out;
        }

        .modal-header {
            font-size: 14px;
            font-weight: 600;
            color: var(--txt);
            margin-bottom: 12px;
        }

        .modal-body {
            font-size: 12px;
            color: var(--txt2);
            margin-bottom: 20px;
            line-height: 1.5;
        }

        .modal-footer {
            display: flex;
            gap: 8px;
            justify-content: flex-end;
        }

        .modal-btn {
            padding: 8px 16px;
            font-size: 11px;
            border: none;
            border-radius: 5px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }

        .modal-btn-primary {
            background: #7fa5df;
            color: #000;
        }

        .modal-btn-primary:hover {
            background: #a3b8d9;
        }

        .modal-btn-secondary {
            background: var(--bg2);
            color: var(--txt2);
            border: 1px solid var(--brd);
        }

        .modal-btn-secondary:hover {
            background: var(--bg3);
            color: var(--txt);
        }
    </style>
</head>
<body>
    <div class="app">
        <!-- Header -->
        <div class="header">
            <b>PDFile</b>
            <span id="fileName">No PDF loaded</span>
            <button class="header-btn" onclick="openMergePDF()" title="Merge PDF" id="mergeBtn" disabled>
                <i data-lucide="file-plus"></i>
            </button>
            <button class="header-btn" onclick="exportPDF()" title="Export PDF" id="exportBtn">
                <i data-lucide="download"></i>
            </button>
            <button class="header-btn" onclick="shareApp()" title="Share PDFile">
                <i data-lucide="share-2"></i>
            </button>
        </div>

        <!-- Main 3-column layout -->
        <div class="main">
            <!-- Left: Page Thumbnails -->
            <div class="thumbnails-panel" id="thumbnailsPanel">
                <div class="thumbnails-header">
                    <span>Pages</span>
                    <button class="collapse-btn" onclick="togglePagesPanel()" title="Collapse/Expand">
                        <i data-lucide="chevron-left" style="width: 16px; height: 16px;"></i>
                    </button>
                </div>

                <!-- Action Toolbar (always visible) -->
                <div class="page-actions-toolbar">
                    <div style="flex: 1;"></div>
                    <button class="page-action-btn arrow-btn" id="moveUpBtn" onclick="moveSelectedPagesUp()" title="Move up" disabled>
                        <i data-lucide="arrow-up" style="width: 14px; height: 14px;"></i>
                    </button>
                    <button class="page-action-btn arrow-btn" id="moveDownBtn" onclick="moveSelectedPagesDown()" title="Move down" disabled>
                        <i data-lucide="arrow-down" style="width: 14px; height: 14px;"></i>
                    </button>
                    <button class="page-action-btn delete-btn" id="deleteSelectedBtn" onclick="removeSelectedPages()" title="Delete selected" disabled>
                        <i data-lucide="trash-2" style="width: 14px; height: 14px;"></i>
                    </button>
                </div>

                <div class="thumbnails-list" id="thumbnailsList">
                    <div style="text-align: center; padding: 20px; font-size: 10px; color: var(--txt3);">
                        Load a PDF to see pages
                    </div>
                </div>

                <div style="display: none; gap: 8px; margin: 8px;">
                    <button class="tool-btn" onclick="applyReorder()" id="reorderBtn" style="flex: 1; display: none;">
                        <i data-lucide="arrow-up-down" style="width: 14px; height: 14px; margin-right: 4px;"></i>
                        Apply Reorder
                    </button>
                    <button class="tool-btn" onclick="removeSelectedPages()" id="removePageBtn" style="flex: 1; display: none;">
                        <i data-lucide="trash-2" style="width: 14px; height: 14px; margin-right: 4px;"></i>
                        Remove Selected
                    </button>
                </div>
            </div>

            <!-- Center: PDF Preview -->
            <div class="preview-panel">
                <div class="preview-area" id="previewArea">
                    <div class="placeholder">
                        <i data-lucide="file" style="width: 48px; height: 48px; opacity: 0.4;"></i>
                        <p>PDF preview will appear here</p>
                        <button class="load-btn" onclick="loadPDF()">Load PDF</button>
                    </div>
                </div>
            </div>

            <!-- Right: Tools -->
            <div class="tools-panel">
                <!-- Overlays Tool -->
                <div class="tool active" id="t-overlays">
                    <div class="tool-header">
                        <i class="icon" data-lucide="layers"></i>
                        <span class="name">Overlays</span>
                    </div>
                    <div class="tool-body">
                        <div class="tool-desc">Add and edit overlay layers</div>

                        <!-- Add New Section -->
                        <div style="margin-bottom: 16px;">
                            <label class="form-label" style="margin-bottom: 8px;">Add New</label>
                            <div style="display: flex; gap: 4px;">
                                <button class="tool-btn" style="flex: 1; font-size: 10px;" onclick="UIControls.showTextEditor()">
                                    <i data-lucide="type" style="width: 12px; height: 12px;"></i> Text
                                </button>
                                <button class="tool-btn" style="flex: 1; font-size: 10px;" onclick="browseImage()">
                                    <i data-lucide="image" style="width: 12px; height: 12px;"></i> Image
                                </button>
                            </div>
                            <input type="file" id="imageFile" accept="image/*" style="display: none;">
                        </div>

                        <!-- Text Editor Modal (hidden by default) -->
                        <div id="textEditorSection" style="display: none; padding: 12px; background: var(--bg); border: 1px solid var(--brd); border-radius: 4px; margin-bottom: 12px;">
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                                <label class="form-label" style="margin: 0;">Text Editor</label>
                                <button onclick="UIControls.closeTextEditor()" style="background: none; border: none; color: var(--txt3); cursor: pointer; padding: 4px;">
                                    <i data-lucide="x" style="width: 14px; height: 14px;"></i>
                                </button>
                            </div>
                            <div class="form-group">
                                <div style="display: flex; gap: 4px;">
                                    <input type="text" class="form-input" id="textContent" placeholder="Enter text..." style="flex: 1;">
                                    <button class="toggle-btn" onclick="openDatePicker()" title="Pick Date">
                                        <i data-lucide="calendar" style="width: 12px; height: 12px;"></i>
                                    </button>
                                </div>
                            </div>
                            <div class="form-group">
                                <button class="toggle-btn" id="dateFormatBtn" onclick="cycleDateFormat()" style="width: 100%; display: none;">
                                    MM/DD/YYYY
                                </button>
                            </div>
                            <button class="tool-btn" id="addTextBtn" onclick="addTextOverlay()" disabled style="width: 100%;">Add Text</button>
                        </div>

                        <!-- Selected Layer Editor (context-sensitive) -->
                        <div id="selectedLayerEditor" style="display: none; padding: 12px; background: var(--bg); border: 1px solid var(--brd); border-radius: 4px; margin-bottom: 12px;">
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                                <label class="form-label" style="margin: 0;" id="selectedLayerTitle">Edit Layer</label>
                                <button onclick="SelectionManager.deselectOverlay()" style="background: none; border: none; color: var(--txt3); cursor: pointer; padding: 4px;">
                                    <i data-lucide="x" style="width: 14px; height: 14px;"></i>
                                </button>
                            </div>

                            <!-- Text-specific controls -->
                            <div id="textLayerControls" style="display: none;">
                                <div class="form-group">
                                    <label class="form-label">Text Content</label>
                                    <input type="text" class="form-input" id="editTextContent" placeholder="Enter text..." oninput="UIControls.updateLayerText(this.value)">
                                </div>
                                <div class="form-group">
                                    <div class="color-input-group">
                                        <div id="textColorPicker"></div>
                                        <label>Text Color</label>
                                    </div>
                                </div>
                                <div class="form-group">
                                    <div class="color-input-group">
                                        <div id="bgColorPicker"></div>
                                        <label>Background</label>
                                    </div>
                                </div>
                            </div>

                            <!-- Common controls (background, opacity) -->
                            <div class="form-group">
                                <label class="form-label" style="display: flex; align-items: center; justify-content: space-between;">
                                    <span id="transparentBtnText">Background Box</span>
                                    <label class="switch" style="margin: 0;">
                                        <input type="checkbox" id="layerTransparentCheckbox" onchange="UIControls.toggleLayerTransparency()">
                                        <span class="slider"></span>
                                    </label>
                                </label>
                                <div style="font-size: 10px; color: var(--txt3); margin-top: 4px;" id="transparentHelpText">
                                    Show colored background box
                                </div>
                            </div>

                            <div class="form-group">
                                <label class="form-label">Layer Opacity: <span id="opacityValue">100</span>%</label>
                                <input type="range" min="10" max="100" value="100" id="opacitySlider" style="width: 100%;" oninput="UIControls.updateLayerOpacity(this.value)">
                                <div style="font-size: 10px; color: var(--txt3); margin-top: 4px;">
                                    Controls overall transparency
                                </div>
                            </div>
                        </div>

                        <!-- Recent Images Section -->
                        <div id="recentImagesGroup" style="display: none; margin-bottom: 12px;">
                            <label class="form-label" style="margin-bottom: 8px;">Recent Images</label>
                            <div id="recentImagesList" style="max-height: 100px; overflow-y: auto; display: flex; flex-direction: column; gap: 4px;">
                                <!-- Recent images will be populated here -->
                            </div>
                        </div>

                        <!-- Layers List -->
                        <div id="layersList" style="display: none;">
                            <label class="form-label" style="margin-bottom: 8px;">Layers</label>
                            <div id="layersContainer" style="max-height: 200px; overflow-y: auto; display: flex; flex-direction: column; gap: 4px;">
                                <!-- Layers will be populated here -->
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Custom Modal -->
    <div class="modal-overlay" id="modalOverlay">
        <div class="modal">
            <div class="modal-header" id="modalHeader">Notification</div>
            <div class="modal-body" id="modalBody">Modal content</div>
            <div class="modal-footer" id="modalFooter">
                <button class="modal-btn modal-btn-primary" onclick="closeModal()">OK</button>
            </div>
        </div>
    </div>

    <!-- Hidden file input -->
    <input type="file" id="fileInput" accept=".pdf" style="display: none;">

    <script>
        // Configure PDF.js worker
        pdfjsLib.GlobalWorkerOptions.workerSrc = '/js/pdf.worker.min.js';

        // ===== STATE =====
        let currentPdfPath = null;
        let currentPdfFile = null;
        let pdfDocument = null;
        let pageOrder = [];
        let mergedPagesData = []; // Stores info about merged pages including images
        let selectedPages = new Set();
        let lastSelectedPage = null; // Track the last selected page for preview
        let pendingOverlays = []; // Store overlays to apply on export
        let selectedOverlayIndex = null; // Track selected overlay for editing
        let currentDateFormat = 'MM/DD/YYYY';
        let dateFormats = ['MM/DD/YYYY', 'DD/MM/YYYY', 'YYYY-MM-DD', 'Month DD, YYYY'];
        let lastPickedDate = null;
        let recentImages = []; // Store recent images {name, data}
        let textContentIsDate = false; // Track if text content is from date picker

        // ================================================================
        // MODULE: State Management
        // Centralized state access and mutations
        // ================================================================
        const AppState = {
            // PDF State
            getPdfDocument: () => pdfDocument,
            setPdfDocument: (doc) => { pdfDocument = doc; },
            getCurrentFile: () => currentPdfFile,
            setCurrentFile: (file) => { currentPdfFile = file; },

            // Overlay State
            getOverlays: () => pendingOverlays,
            getOverlay: (index) => pendingOverlays[index],
            addOverlay: (overlay) => pendingOverlays.push(overlay),
            removeOverlay: (index) => pendingOverlays.splice(index, 1),
            updateOverlay: (index, updates) => Object.assign(pendingOverlays[index], updates),

            // Selection State
            getSelectedIndex: () => selectedOverlayIndex,
            setSelectedIndex: (index) => { selectedOverlayIndex = index; },

            // Page State
            getSelectedPages: () => selectedPages,
            getLastSelectedPage: () => lastSelectedPage,
            setLastSelectedPage: (page) => { lastSelectedPage = page; }
        };

        // ================================================================
        // MODULE: UI Controls
        // Handles UI interactions and updates
        // ================================================================
        const UIControls = {
            showTextEditor() {
                document.getElementById('textEditorSection').style.display = 'block';
                document.getElementById('selectedLayerEditor').style.display = 'none';
                document.getElementById('textContent').focus();
            },

            closeTextEditor() {
                document.getElementById('textEditorSection').style.display = 'none';
                document.getElementById('textContent').value = '';
                document.getElementById('dateFormatBtn').style.display = 'none';
                updateAddTextButtonState();
            },

            showLayerEditor(overlay, index) {
                const editor = document.getElementById('selectedLayerEditor');
                const textControls = document.getElementById('textLayerControls');
                const transparentCheckbox = document.getElementById('layerTransparentCheckbox');
                const transparentBtnText = document.getElementById('transparentBtnText');
                const transparentHelpText = document.getElementById('transparentHelpText');
                const titleEl = document.getElementById('selectedLayerTitle');
                const opacitySlider = document.getElementById('opacitySlider');
                const opacityValue = document.getElementById('opacityValue');

                editor.style.display = 'block';
                document.getElementById('textEditorSection').style.display = 'none';

                const isText = overlay.type === 'date' || overlay.type === 'text';

                // Set title
                titleEl.textContent = isText ? 'Edit Text' : 'Edit Image';

                // Show/hide text-specific controls
                textControls.style.display = isText ? 'block' : 'none';

                // Update transparency checkbox label and help text
                if (isText) {
                    transparentBtnText.textContent = 'Background Box';
                    transparentHelpText.textContent = 'Show colored background box';
                    // For text: checkbox ON = background visible, OFF = transparent
                    const hasBg = !overlay.transparentBg && overlay.bgColor;
                    transparentCheckbox.checked = hasBg;
                } else {
                    transparentBtnText.textContent = 'Remove Background';
                    transparentHelpText.textContent = 'Remove image background (uses AI)';
                    // For images: checkbox ON = remove background
                    transparentCheckbox.checked = overlay.removeBackground || false;
                }

                // Set opacity
                const opacity = overlay.opacity || 100;
                opacitySlider.value = opacity;
                opacityValue.textContent = opacity;

                // Load text content if text overlay
                if (isText) {
                    document.getElementById('editTextContent').value = overlay.dateText || '';

                    // Update color pickers
                    if (textColorPicker) {
                        const textColor = overlay.textColor || '#000000';
                        textColorPicker.setColor(textColor);
                        selectedTextColor = textColor;
                    }

                    if (bgColorPicker) {
                        const bgColor = overlay.bgColor || '#ffffff';
                        bgColorPicker.setColor(bgColor);
                        selectedBgColor = bgColor;
                    }

                    // Show date format button if this is a date overlay
                    if (overlay.type === 'date') {
                        document.getElementById('dateFormatBtn').style.display = 'block';
                        document.getElementById('dateFormatBtn').textContent = currentDateFormat;
                    } else {
                        document.getElementById('dateFormatBtn').style.display = 'none';
                    }
                } else {
                    // Hide date format button for non-text overlays
                    document.getElementById('dateFormatBtn').style.display = 'none';
                }

                lucide.createIcons();
            },

            toggleLayerTransparency() {
                const index = AppState.getSelectedIndex();
                if (index === null) return;

                const overlay = AppState.getOverlay(index);
                const isText = overlay.type === 'date' || overlay.type === 'text';
                const checkbox = document.getElementById('layerTransparentCheckbox');

                if (isText) {
                    // For text: checkbox ON = show background, OFF = transparent
                    const showBg = checkbox.checked;
                    overlay.transparentBg = !showBg;
                    overlay.bgColor = showBg ? selectedBgColor : null;

                    // Update gizmo background color
                    const gizmo = document.querySelector(`.overlay-gizmo[data-overlay-index="${index}"]`);
                    if (gizmo) {
                        const textEl = gizmo.querySelector('.overlay-gizmo-text');
                        if (textEl) {
                            textEl.style.backgroundColor = showBg ? selectedBgColor : 'transparent';
                        }
                    }
                } else {
                    // For images: checkbox ON = remove background
                    overlay.removeBackground = checkbox.checked;
                }

                lucide.createIcons();
            },

            updateLayerOpacity(value) {
                document.getElementById('opacityValue').textContent = value;
                const index = AppState.getSelectedIndex();
                if (index !== null) {
                    AppState.updateOverlay(index, { opacity: parseInt(value) });
                    // Update gizmo opacity in real-time
                    const gizmo = document.querySelector(`.overlay-gizmo[data-overlay-index="${index}"]`);
                    if (gizmo) {
                        gizmo.style.opacity = parseInt(value) / 100;
                    }
                }
            },

            updateLayerText(newText) {
                const index = AppState.getSelectedIndex();
                if (index === null) return;

                const overlay = AppState.getOverlay(index);
                if (overlay.type !== 'date' && overlay.type !== 'text') return;

                AppState.updateOverlay(index, { dateText: newText });

                // Update gizmo with new text
                const label = newText.length > 20 ? `${newText.substring(0, 20)}...` : newText;
                const gizmo = document.querySelector(`.overlay-gizmo[data-overlay-index="${index}"]`);
                if (gizmo) {
                    const labelEl = gizmo.querySelector('.overlay-gizmo-label');
                    if (labelEl) labelEl.textContent = label;
                    const textEl = gizmo.querySelector('.overlay-gizmo-text');
                    if (textEl) textEl.textContent = newText;
                }

                LayerManager.updateLayersList();
            },

            updateLayerColor(color, isBackground = false) {
                const index = AppState.getSelectedIndex();
                if (index === null) return;

                const overlay = AppState.getOverlay(index);
                if (overlay.type !== 'date' && overlay.type !== 'text') return;

                if (isBackground) {
                    selectedBgColor = color;
                    if (!overlay.transparentBg) {
                        AppState.updateOverlay(index, { bgColor: color });
                        // Update gizmo
                        const gizmo = document.querySelector(`.overlay-gizmo[data-overlay-index="${index}"]`);
                        if (gizmo) {
                            const textEl = gizmo.querySelector('.overlay-gizmo-text');
                            if (textEl) textEl.style.backgroundColor = color;
                        }
                    }
                } else {
                    selectedTextColor = color;
                    AppState.updateOverlay(index, { textColor: color });
                    // Update gizmo
                    const gizmo = document.querySelector(`.overlay-gizmo[data-overlay-index="${index}"]`);
                    if (gizmo) {
                        const textEl = gizmo.querySelector('.overlay-gizmo-text');
                        if (textEl) textEl.style.color = color;
                    }
                }
            }
        };

        // ================================================================
        // MODULE: Selection Manager
        // Handles overlay selection and deselection
        // ================================================================
        const SelectionManager = {
            selectOverlay(index) {
                const overlay = AppState.getOverlay(index);
                if (!overlay) return;

                AppState.setSelectedIndex(index);

                // Update layer item selection
                const layerItems = document.querySelectorAll('.layer-item');
                layerItems.forEach((item, i) => {
                    item.classList.toggle('selected', i === index);
                });

                // Update gizmo selection
                const gizmos = document.querySelectorAll('.overlay-gizmo');
                gizmos.forEach((gizmo) => {
                    const gizmoIndex = parseInt(gizmo.dataset.overlayIndex);
                    gizmo.classList.toggle('selected', gizmoIndex === index);
                });

                // Show layer editor
                UIControls.showLayerEditor(overlay, index);
            },

            deselectOverlay() {
                AppState.setSelectedIndex(null);

                // Clear layer selection
                const layerItems = document.querySelectorAll('.layer-item');
                layerItems.forEach(item => item.classList.remove('selected'));

                // Clear gizmo selection
                const gizmos = document.querySelectorAll('.overlay-gizmo');
                gizmos.forEach(gizmo => gizmo.classList.remove('selected'));

                // Hide layer editor
                document.getElementById('selectedLayerEditor').style.display = 'none';

                lucide.createIcons();
            }
        };

        // ================================================================
        // MODULE: Layer Manager
        // Manages layer list and operations
        // ================================================================
        const LayerManager = {
            updateLayersList() {
                const layersList = document.getElementById('layersList');
                const layersContainer = document.getElementById('layersContainer');
                const overlays = AppState.getOverlays();

                if (overlays.length === 0) {
                    layersList.style.display = 'none';
                    return;
                }

                layersList.style.display = 'block';
                layersContainer.innerHTML = '';

                overlays.forEach((overlay, index) => {
                    const layerItem = document.createElement('div');
                    layerItem.className = 'layer-item';
                    if (AppState.getSelectedIndex() === index) {
                        layerItem.classList.add('selected');
                    }

                    const iconName = overlay.type === 'date' || overlay.type === 'text' ? 'type' : 'image';
                    const displayName = overlay.dateText || overlay.type || 'Layer';

                    layerItem.innerHTML = `
                        <i class="layer-icon" data-lucide="${iconName}" style="width: 14px; height: 14px;"></i>
                        <span class="layer-name">${displayName}</span>
                        <div class="layer-controls">
                            <button class="layer-btn" onclick="LayerManager.moveLayerUp(${index})" ${index === 0 ? 'disabled' : ''} title="Move up">
                                <i data-lucide="arrow-up" style="width: 10px; height: 10px;"></i>
                            </button>
                            <button class="layer-btn" onclick="LayerManager.moveLayerDown(${index})" ${index === overlays.length - 1 ? 'disabled' : ''} title="Move down">
                                <i data-lucide="arrow-down" style="width: 10px; height: 10px;"></i>
                            </button>
                        </div>
                    `;

                    layerItem.addEventListener('click', (e) => {
                        if (!e.target.closest('.layer-controls')) {
                            SelectionManager.selectOverlay(index);
                        }
                    });

                    layersContainer.appendChild(layerItem);
                });

                lucide.createIcons();
            },

            moveLayerUp(index) {
                if (index === 0) return;

                const overlays = AppState.getOverlays();
                [overlays[index - 1], overlays[index]] = [overlays[index], overlays[index - 1]];

                // Update selected index if needed
                const selectedIndex = AppState.getSelectedIndex();
                if (selectedIndex === index) {
                    AppState.setSelectedIndex(index - 1);
                } else if (selectedIndex === index - 1) {
                    AppState.setSelectedIndex(index);
                }

                updateGizmosForPage(currentPreviewPage);
                this.updateLayersList();
            },

            moveLayerDown(index) {
                const overlays = AppState.getOverlays();
                if (index === overlays.length - 1) return;

                [overlays[index], overlays[index + 1]] = [overlays[index + 1], overlays[index]];

                // Update selected index if needed
                const selectedIndex = AppState.getSelectedIndex();
                if (selectedIndex === index) {
                    AppState.setSelectedIndex(index + 1);
                } else if (selectedIndex === index + 1) {
                    AppState.setSelectedIndex(index);
                }

                updateGizmosForPage(currentPreviewPage);
                this.updateLayersList();
            }
        };

        // ===== PANEL COLLAPSE =====
        function togglePagesPanel() {
            const panel = document.getElementById('thumbnailsPanel');
            panel.classList.toggle('collapsed');
            lucide.createIcons();
        }

        // ===== MODAL SYSTEM =====
        let modalCallback = null;

        function showModal(title, message) {
            const overlay = document.getElementById('modalOverlay');
            const header = document.getElementById('modalHeader');
            const body = document.getElementById('modalBody');
            const footer = document.getElementById('modalFooter');

            header.textContent = title;
            body.textContent = message;
            footer.innerHTML = '<button class="modal-btn modal-btn-primary" onclick="closeModal()">OK</button>';

            overlay.classList.add('active');
        }

        function showConfirmModal(title, message, onConfirm) {
            const overlay = document.getElementById('modalOverlay');
            const header = document.getElementById('modalHeader');
            const body = document.getElementById('modalBody');
            const footer = document.getElementById('modalFooter');

            header.textContent = title;
            body.textContent = message;
            footer.innerHTML = `
                <button class="modal-btn modal-btn-secondary" onclick="closeModal()">Cancel</button>
                <button class="modal-btn modal-btn-primary" onclick="confirmModal()">Confirm</button>
            `;

            modalCallback = onConfirm;
            overlay.classList.add('active');
        }

        function confirmModal() {
            if (modalCallback) {
                modalCallback();
                modalCallback = null;
            }
            closeModal();
        }

        function closeModal() {
            document.getElementById('modalOverlay').classList.remove('active');
            modalCallback = null;
        }

        // Close modal on overlay click
        document.getElementById('modalOverlay').addEventListener('click', (e) => {
            if (e.target.id === 'modalOverlay') closeModal();
        });

        // ===== PDF LOADING =====
        async function loadInitialPDF() {
            try {
                const response = await fetch('/api/file');
                const data = await response.json();

                if (data.filePath) {
                    currentPdfPath = data.filePath;
                    currentPdfFile = data.fileName;
                    document.getElementById('fileName').textContent = data.fileName;

                    // Enable merge button
                    document.getElementById('mergeBtn').disabled = false;

                    // Load PDF preview
                    const previewArea = document.getElementById('previewArea');
                    previewArea.innerHTML = `<div class="canvas-wrapper"><canvas id="pdfCanvas"></canvas></div>`;

                    // Add click handler to deselect overlays when clicking canvas background
                    const canvasWrapper = document.querySelector('.canvas-wrapper');
                    if (canvasWrapper) {
                        canvasWrapper.addEventListener('click', (e) => {
                            // Only deselect if clicking directly on canvas or wrapper, not on gizmos
                            if (e.target === canvasWrapper || e.target.id === 'pdfCanvas') {
                                SelectionManager.deselectOverlay();
                            }
                        });
                    }

                    // Add mouse wheel zoom handler to preview area
                    if (previewArea) {
                        let zoomTimeout;
                        previewArea.addEventListener('wheel', (e) => {
                            // Only zoom when Ctrl key is held, otherwise allow normal scrolling
                            if (!e.ctrlKey) return;

                            e.preventDefault();

                            // Zoom in (scroll up) or zoom out (scroll down)
                            const delta = e.deltaY < 0 ? 0.1 : -0.1;

                            // Debounce zoom updates to reduce glitchiness
                            clearTimeout(zoomTimeout);
                            zoomTimeout = setTimeout(() => {
                                setZoomLevel(zoomLevel + delta);
                            }, 10);
                        }, { passive: false });
                    }

                    // Reset zoom to 100% and render first page
                    zoomLevel = 1.0;
                    await generateThumbnails(data.filePath);
                    await renderPreviewPage(1);
                }
            } catch (err) {
                console.error('Failed to load initial PDF:', err);
            }
        }

        function loadPDF() {
            const fileInput = document.getElementById('fileInput');
            fileInput.onchange = async (e) => {
                const file = e.target.files[0];
                if (file && file.name.toLowerCase().endsWith('.pdf')) {
                    await loadPDFFile(file);
                } else {
                    showModal('Invalid File', 'Please select a PDF file');
                }
                fileInput.value = '';
            };
            fileInput.click();
        }

        async function loadPDFFile(file) {
            try {
                const objectUrl = URL.createObjectURL(file);
                currentPdfFile = file.name;
                document.getElementById('fileName').textContent = file.name;

                // Enable merge button
                document.getElementById('mergeBtn').disabled = false;

                // Clear merged pages data when loading new PDF
                mergedPagesData = [];

                // Show preview
                const previewArea = document.getElementById('previewArea');
                previewArea.innerHTML = `<div class="canvas-wrapper"><canvas id="pdfCanvas"></canvas></div>`;

                // Load PDF for thumbnails
                const arrayBuffer = await file.arrayBuffer();
                pdfDocument = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;

                // Reset zoom to 100%
                zoomLevel = 1.0;

                await generateThumbnailsFromDoc();
                await renderPreviewPage(1);

                showModal('Success', `Loaded: ${file.name}`);
            } catch (err) {
                showModal('Error', `Failed to load PDF: ${err.message}`);
            }
        }

        // ===== THUMBNAIL GENERATION =====
        async function generateThumbnails(filePath) {
            try {
                const response = await fetch(`/pdf/${encodeURIComponent(currentPdfFile)}`);
                const arrayBuffer = await response.arrayBuffer();
                pdfDocument = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
                await generateThumbnailsFromDoc();
            } catch (err) {
                console.error('Failed to generate thumbnails:', err);
            }
        }

        async function generateThumbnailsFromDoc() {
            const thumbnailsList = document.getElementById('thumbnailsList');
            thumbnailsList.innerHTML = '';

            const pageCount = pdfDocument.numPages;
            pageOrder = Array.from({ length: pageCount }, (_, i) => i + 1);

            for (let pageNum = 1; pageNum <= pageCount; pageNum++) {
                const page = await pdfDocument.getPage(pageNum);
                const viewport = page.getViewport({ scale: 0.3 });

                const canvas = document.createElement('canvas');
                const context = canvas.getContext('2d');
                canvas.width = viewport.width;
                canvas.height = viewport.height;

                await page.render({ canvasContext: context, viewport }).promise;

                const item = document.createElement('div');
                item.className = 'thumbnail-item';
                item.draggable = true;
                item.dataset.pageNum = pageNum;
                item.innerHTML = `
                    <canvas class="thumbnail-canvas"></canvas>
                    <div class="thumbnail-number">${pageNum}</div>
                `;
                const thumbCanvas = item.querySelector('canvas');
                thumbCanvas.width = canvas.width;
                thumbCanvas.height = canvas.height;
                thumbCanvas.getContext('2d').drawImage(canvas, 0, 0);

                // Click to toggle selection
                item.addEventListener('click', (e) => {
                    const currentPageNum = parseInt(e.currentTarget.dataset.pageNum);
                    const isSelected = selectedPages.has(currentPageNum);
                    handlePageSelection(currentPageNum, !isSelected);
                });

                // Drag and drop for reordering
                item.addEventListener('dragstart', handleDragStart);
                item.addEventListener('dragover', handleDragOver);
                item.addEventListener('drop', handleDrop);
                item.addEventListener('dragend', handleDragEnd);

                thumbnailsList.appendChild(item);
            }
        }

        // ===== PDF PREVIEW RENDERING =====
        let currentPreviewPage = 1;
        let previewScale = 1;
        let zoomLevel = 1.0; // 1.0 = 100%, 2.0 = 200%

        async function renderPreviewPage(pageNum) {
            if (!pdfDocument) return;

            try {
                currentPreviewPage = pageNum;
                const canvas = document.getElementById('pdfCanvas');
                if (!canvas) return;

                const page = await pdfDocument.getPage(pageNum);

                // Calculate base scale to fill width
                const previewArea = document.getElementById('previewArea');
                const containerWidth = previewArea.clientWidth - 20;
                const pageViewport = page.getViewport({ scale: 1 });

                const baseScale = containerWidth / pageViewport.width; // Fill width

                // Apply zoom level (100% to 200%)
                const scale = baseScale * zoomLevel;
                previewScale = scale;

                const viewport = page.getViewport({ scale });

                canvas.width = viewport.width;
                canvas.height = viewport.height;

                const context = canvas.getContext('2d');
                await page.render({ canvasContext: context, viewport }).promise;

                // Update gizmos visibility for current page (overlays are only rendered server-side on export)
                updateGizmosForPage(pageNum);
            } catch (err) {
                console.error('Error rendering preview page:', err);
            }
        }

        function setZoomLevel(newZoom) {
            zoomLevel = Math.max(0.5, Math.min(3.0, newZoom)); // Clamp between 50% and 300%
            renderPreviewPage(currentPreviewPage);
        }

        function updateGizmosForPage(pageNum) {
            // Remove all existing gizmos
            document.querySelectorAll('.overlay-gizmo').forEach(g => g.remove());

            // Recreate gizmos only for the current page
            pendingOverlays.forEach((overlay, i) => {
                const overlayPage = (overlay.pageIndex || 0) + 1;
                if (overlayPage === pageNum) {
                    const label = overlay.type === 'date' ? `Date: ${overlay.dateText || 'Today'}` :
                                 overlay.type === 'text' ? `Text: ${overlay.text || overlay.dateText}` :
                                 overlay.type === 'image' ? 'Image' : 'Signature';
                    addOverlayGizmo(overlay.type, label, overlay.x, overlay.y, i);
                }
            });
        }

        let draggedElement = null;

        function handleDragStart(e) {
            draggedElement = e.target.closest('.thumbnail-item');
            draggedElement.classList.add('dragging');
            e.dataTransfer.effectAllowed = 'move';
        }

        function handleDragOver(e) {
            if (e.preventDefault) e.preventDefault();
            e.dataTransfer.dropEffect = 'move';

            // Remove dragover from all items first
            document.querySelectorAll('.thumbnail-item.dragover').forEach(item => {
                item.classList.remove('dragover');
            });

            const target = e.target.closest('.thumbnail-item');
            if (target && target !== draggedElement) {
                target.classList.add('dragover');
            }
            return false;
        }

        function handleDrop(e) {
            if (e.stopPropagation) e.stopPropagation();
            e.preventDefault();

            const target = e.target.closest('.thumbnail-item');
            if (target && draggedElement && target !== draggedElement) {
                const draggedIndex = parseInt(draggedElement.dataset.pageNum) - 1;
                const targetIndex = parseInt(target.dataset.pageNum) - 1;

                // Swap in pageOrder array
                [pageOrder[draggedIndex], pageOrder[targetIndex]] = [pageOrder[targetIndex], pageOrder[draggedIndex]];

                // Visual swap
                const parent = target.parentNode;
                if (draggedElement.compareDocumentPosition(target) & Node.DOCUMENT_POSITION_FOLLOWING) {
                    parent.insertBefore(draggedElement, target);
                } else {
                    parent.insertBefore(draggedElement, target.nextSibling);
                }

                // Update page numbers
                updatePageNumbers();

                // Show reorder button
                const reorderBtn = document.getElementById('reorderBtn');
                if (reorderBtn) reorderBtn.style.display = 'block';
            }

            // Clean up drag classes
            document.querySelectorAll('.thumbnail-item').forEach(item => {
                item.classList.remove('dragover', 'dragging');
            });

            return false;
        }

        function handleDragEnd() {
            document.querySelectorAll('.thumbnail-item').forEach(item => {
                item.classList.remove('dragging', 'dragover');
            });
        }

        // Handle page selection
        function handlePageSelection(pageNum, isSelected) {
            if (isSelected) {
                selectedPages.add(pageNum);
                lastSelectedPage = pageNum;
                // Show the selected page in preview (always show the last selected one)
                renderPreviewPage(pageNum);
            } else {
                selectedPages.delete(pageNum);
                // If we're unselecting the last selected page, update to another selected page
                if (lastSelectedPage === pageNum) {
                    lastSelectedPage = selectedPages.size > 0 ? Array.from(selectedPages)[0] : null;
                }
                // If there are still selected pages, show one of them
                if (selectedPages.size > 0 && lastSelectedPage) {
                    renderPreviewPage(lastSelectedPage);
                }
            }

            // Update visual selection
            const items = document.querySelectorAll('.thumbnail-item');
            items.forEach(item => {
                const num = parseInt(item.dataset.pageNum);
                const isItemSelected = selectedPages.has(num);
                item.classList.toggle('selected', isItemSelected);

                // Add or remove checkmark
                let checkmark = item.querySelector('.thumbnail-checkmark');
                if (isItemSelected && !checkmark) {
                    checkmark = document.createElement('div');
                    checkmark.className = 'thumbnail-checkmark';
                    checkmark.innerHTML = '<i data-lucide="check" style="width: 18px; height: 18px;"></i>';
                    item.appendChild(checkmark);
                    lucide.createIcons();
                } else if (!isItemSelected && checkmark) {
                    checkmark.remove();
                }
            });

            // Update button states
            const hasSelection = selectedPages.size > 0;
            document.getElementById('deleteSelectedBtn').disabled = !hasSelection;

            // Smart disable for arrows based on position
            if (hasSelection) {
                const selectedArray = Array.from(selectedPages);
                const minPage = Math.min(...selectedArray);
                const maxPage = Math.max(...selectedArray);
                const totalPages = document.querySelectorAll('.thumbnail-item').length;

                document.getElementById('moveUpBtn').disabled = minPage === 1;
                document.getElementById('moveDownBtn').disabled = maxPage === totalPages;
            } else {
                document.getElementById('moveUpBtn').disabled = true;
                document.getElementById('moveDownBtn').disabled = true;
            }
        }

        function moveSelectedPagesUp() {
            if (selectedPages.size === 0) return;

            const items = Array.from(document.querySelectorAll('.thumbnail-item'));
            const selectedArray = Array.from(selectedPages).sort((a, b) => a - b);

            // Can't move up if first page is selected
            if (selectedArray[0] === 1) return;

            // Move each selected page up by swapping with the page above
            for (const pageNum of selectedArray) {
                const currentIndex = pageNum - 1;
                const targetIndex = currentIndex - 1;

                if (targetIndex >= 0 && !selectedPages.has(targetIndex + 1)) {
                    // Swap in DOM
                    const currentItem = items[currentIndex];
                    const targetItem = items[targetIndex];
                    targetItem.parentNode.insertBefore(currentItem, targetItem);

                    // Update items array
                    [items[currentIndex], items[targetIndex]] = [items[targetIndex], items[currentIndex]];
                }
            }

            updatePageNumbers();
            lucide.createIcons();
        }

        function moveSelectedPagesDown() {
            if (selectedPages.size === 0) return;

            const items = Array.from(document.querySelectorAll('.thumbnail-item'));
            const selectedArray = Array.from(selectedPages).sort((a, b) => b - a); // Reverse order

            // Can't move down if last page is selected
            if (selectedArray[0] === items.length) return;

            // Move each selected page down by swapping with the page below
            for (const pageNum of selectedArray) {
                const currentIndex = pageNum - 1;
                const targetIndex = currentIndex + 1;

                if (targetIndex < items.length && !selectedPages.has(targetIndex + 1)) {
                    // Swap in DOM
                    const currentItem = items[currentIndex];
                    const targetItem = items[targetIndex];
                    targetItem.parentNode.insertBefore(targetItem, currentItem);

                    // Update items array
                    [items[currentIndex], items[targetIndex]] = [items[targetIndex], items[currentIndex]];
                }
            }

            updatePageNumbers();
            lucide.createIcons();
        }

        function updatePageNumbers() {
            const items = document.querySelectorAll('.thumbnail-item');
            const oldToNew = new Map();

            items.forEach((item, index) => {
                const oldPageNum = parseInt(item.dataset.pageNum);
                // Preserve original page number on first reorder
                if (!item.dataset.originalPage) {
                    item.dataset.originalPage = oldPageNum;
                }
                const newPageNum = index + 1;
                item.querySelector('.thumbnail-number').textContent = newPageNum;
                item.dataset.pageNum = newPageNum;
                oldToNew.set(oldPageNum, newPageNum);
            });

            // Update selectedPages set with new page numbers
            const newSelectedPages = new Set();
            selectedPages.forEach(oldNum => {
                if (oldToNew.has(oldNum)) {
                    newSelectedPages.add(oldToNew.get(oldNum));
                }
            });
            selectedPages = newSelectedPages;

            // Update lastSelectedPage with new page number
            if (lastSelectedPage && oldToNew.has(lastSelectedPage)) {
                lastSelectedPage = oldToNew.get(lastSelectedPage);
            }

            // Refresh visual selection with checkmarks
            items.forEach(item => {
                const num = parseInt(item.dataset.pageNum);
                const isSelected = selectedPages.has(num);
                item.classList.toggle('selected', isSelected);

                // Add or remove checkmark
                let checkmark = item.querySelector('.thumbnail-checkmark');
                if (isSelected && !checkmark) {
                    checkmark = document.createElement('div');
                    checkmark.className = 'thumbnail-checkmark';
                    checkmark.innerHTML = '<i data-lucide="check" style="width: 18px; height: 18px;"></i>';
                    item.appendChild(checkmark);
                    lucide.createIcons();
                } else if (!isSelected && checkmark) {
                    checkmark.remove();
                }
            });

            // Update button states after reordering
            if (selectedPages.size > 0) {
                const selectedArray = Array.from(selectedPages);
                const minPage = Math.min(...selectedArray);
                const maxPage = Math.max(...selectedArray);
                const totalPages = items.length;

                document.getElementById('moveUpBtn').disabled = minPage === 1;
                document.getElementById('moveDownBtn').disabled = maxPage === totalPages;
            }

            // Update overlay page indices based on new page order
            pendingOverlays.forEach(overlay => {
                // Convert 0-indexed pageIndex to 1-indexed page number
                const oldPageNum = overlay.pageIndex + 1;

                // Get new page number from mapping
                if (oldToNew.has(oldPageNum)) {
                    const newPageNum = oldToNew.get(oldPageNum);
                    // Convert back to 0-indexed
                    overlay.pageIndex = newPageNum - 1;
                }
            });

            // Rebuild pageOrder array from current DOM order
            pageOrder = Array.from(items).map((item, index) => index + 1);

            // Update gizmos for current page since overlays may have changed
            updateGizmosForPage(currentPreviewPage);
        }

        async function applyReorder() {
            if (!currentPdfFile) {
                showModal('No PDF Loaded', 'Please load a PDF first');
                return;
            }

            // Get current page order from thumbnails
            const items = document.querySelectorAll('.thumbnail-item');
            const pageOrder = Array.from(items).map(item => parseInt(item.dataset.pageNum));

            showConfirmModal(
                'Apply Reorder',
                'Apply the new page order? This will download a reordered PDF file.',
                async () => {
                    try {
                        showModal('Processing', 'Reordering pages...');

                        const response = await fetch('/api/reorder-pages', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ order: pageOrder })
                        });

                        if (!response.ok) throw new Error('Reorder failed');

                        const blob = await response.blob();
                        const url = window.URL.createObjectURL(blob);
                        const a = document.createElement('a');
                        a.href = url;
                        a.download = `${currentPdfFile.replace('.pdf', '')}_reordered.pdf`;
                        document.body.appendChild(a);
                        a.click();
                        window.URL.revokeObjectURL(url);
                        document.body.removeChild(a);

                        closeModal();
                        showModal('Success', 'Pages reordered successfully!');
                        document.getElementById('reorderBtn').style.display = 'none';
                    } catch (err) {
                        closeModal();
                        showModal('Error', `Failed to reorder pages: ${err.message}`);
                    }
                }
            );
        }

        // ===== TOOL FUNCTIONS =====
        function toggleTool(toolId) {
            const tools = document.querySelectorAll('.tool');
            const clickedTool = document.getElementById(toolId);

            tools.forEach(tool => {
                if (tool.id === toolId) {
                    tool.classList.toggle('active');
                } else {
                    tool.classList.remove('active');
                }
            });
        }

        function switchOverlayTab(tabName) {
            document.querySelectorAll('.tabs .tab').forEach((tab, i) => {
                tab.classList.toggle('active', ['text', 'image'][i] === tabName);
            });
            document.querySelectorAll('.tab-content').forEach((content, i) => {
                content.classList.toggle('active', ['text', 'image'][i] === tabName);
            });
        }

        function cycleDateFormat() {
            const currentIndex = dateFormats.indexOf(currentDateFormat);
            const nextIndex = (currentIndex + 1) % dateFormats.length;
            currentDateFormat = dateFormats[nextIndex];
            document.getElementById('dateFormatBtn').textContent = currentDateFormat;

            // If a date was already picked, update the text field with new format
            if (lastPickedDate) {
                const textInput = document.getElementById('textContent');
                textInput.value = formatDateByFormat(lastPickedDate, currentDateFormat);
                textContentIsDate = true; // Mark as date content
            }
        }

        function updateAddTextButtonState() {
            const textInput = document.getElementById('textContent');
            const addTextBtn = document.getElementById('addTextBtn');
            const hasContent = textInput.value.trim().length > 0;
            addTextBtn.disabled = !hasContent;
        }

        function onTextContentChange() {
            updateAddTextButtonState();

            // If manually edited, hide date format button (user typed custom text)
            if (!textContentIsDate) {
                document.getElementById('dateFormatBtn').style.display = 'none';
            }
        }

        function browseImage() {
            document.getElementById('imageFile').click();
        }

        // toggleOverlayTransparent removed - now using UIControls.toggleLayerTransparency from panel

        function loadRecentImages() {
            try {
                const stored = localStorage.getItem('pdfile_recent_images');
                if (stored) {
                    recentImages = JSON.parse(stored);
                    updateRecentImagesList();
                }
            } catch (e) {
                console.error('Failed to load recent images:', e);
            }
        }

        function saveRecentImages() {
            try {
                localStorage.setItem('pdfile_recent_images', JSON.stringify(recentImages));
            } catch (e) {
                console.error('Failed to save recent images:', e);
            }
        }

        function addToRecentImages(name, data) {
            // Remove if already exists
            recentImages = recentImages.filter(img => img.name !== name);

            // Add to beginning
            recentImages.unshift({ name, data });

            // Keep only last 5
            if (recentImages.length > 5) {
                recentImages = recentImages.slice(0, 5);
            }

            saveRecentImages();
            updateRecentImagesList();
        }

        function updateRecentImagesList() {
            const listEl = document.getElementById('recentImagesList');
            const groupEl = document.getElementById('recentImagesGroup');

            if (recentImages.length === 0) {
                groupEl.style.display = 'none';
                return;
            }

            groupEl.style.display = 'block';
            listEl.innerHTML = '';

            recentImages.forEach((img, index) => {
                const item = document.createElement('div');
                item.className = 'recent-image-item';
                item.innerHTML = `
                    <img src="${img.data}" alt="${img.name}">
                    <span class="name">${img.name}</span>
                    <button class="insert-btn" onclick="insertRecentImage(${index})">Insert</button>
                `;
                listEl.appendChild(item);
            });
        }

        function insertRecentImage(index) {
            if (!currentPdfFile) return;

            const img = recentImages[index];
            if (!img) return;

            const overlayIndex = AppState.getOverlays().length;

            AppState.addOverlay({
                type: 'image',
                imageData: img.data,
                x: 100,
                y: 100,
                width: 150,
                height: 150,
                opacity: 100,
                removeBackground: false,
                pageIndex: currentPreviewPage - 1
            });

            addOverlayGizmo('image', 'Image', 100, 100, overlayIndex);
            LayerManager.updateLayersList();
        }

        function openDatePicker() {
            if (datePicker) {
                datePicker.open();
            }
        }

        function openMergePDF() {
            if (!currentPdfFile) return;

            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.pdf,image/*';
            input.onchange = (e) => {
                const file = e.target.files[0];
                if (file) {
                    showMergeDialog(file);
                }
            };
            input.click();
        }

        function showMergeDialog(file) {
            const modal = document.getElementById('modalOverlay');
            const header = document.getElementById('modalHeader');
            const body = document.getElementById('modalBody');
            const footer = document.getElementById('modalFooter');

            // Determine file type
            const fileType = file.type.toLowerCase();
            const fileName = file.name.toLowerCase();
            const isImage = fileType.startsWith('image/') || fileName.match(/\.(jpg|jpeg|png|gif|bmp|webp)$/);
            const isPdf = fileType === 'application/pdf' || fileName.endsWith('.pdf');

            let fileTypeLabel = 'file';
            if (isImage) fileTypeLabel = 'image';
            else if (isPdf) fileTypeLabel = 'PDF';

            header.textContent = `Merge ${fileTypeLabel.charAt(0).toUpperCase() + fileTypeLabel.slice(1)}`;
            body.innerHTML = `
                <p>How would you like to merge "${file.name}"?</p>
                ${isImage ? '<p style="font-size: 10px; color: var(--txt3); margin-top: 8px;">Image will be added as a full page.</p>' : ''}
            `;
            footer.innerHTML = `
                <button class="modal-btn modal-btn-secondary" onclick="closeModal()">Cancel</button>
                <button class="modal-btn modal-btn-secondary" onclick="closeModal(); mergeFiles('beginning', '${file.name}')">Add to Beginning</button>
                <button class="modal-btn modal-btn-primary" onclick="closeModal(); mergeFiles('end', '${file.name}')">Add to End</button>
            `;

            // Store file for merge
            window.pendingMergeFile = file;
            modal.classList.add('active');
        }

        function formatDateByFormat(date, format) {
            const months = ['January', 'February', 'March', 'April', 'May', 'June',
                          'July', 'August', 'September', 'October', 'November', 'December'];

            const mm = String(date.getMonth() + 1).padStart(2, '0');
            const dd = String(date.getDate()).padStart(2, '0');
            const yyyy = date.getFullYear();

            switch(format) {
                case 'MM/DD/YYYY':
                    return `${mm}/${dd}/${yyyy}`;
                case 'DD/MM/YYYY':
                    return `${dd}/${mm}/${yyyy}`;
                case 'YYYY-MM-DD':
                    return `${yyyy}-${mm}-${dd}`;
                case 'Month DD, YYYY':
                    return `${months[date.getMonth()]} ${dd}, ${yyyy}`;
                default:
                    return `${mm}/${dd}/${yyyy}`;
            }
        }

        function addTextOverlay() {
            const textInput = document.getElementById('textContent');
            const text = textInput.value;
            if (!text.trim()) return;

            const textColor = selectedTextColor;

            // Add new overlay (default to transparent background)
            const overlayIndex = AppState.getOverlays().length;
            AppState.addOverlay({
                type: 'date', // Using date type since it handles text rendering
                dateText: text,
                x: 100,
                y: 100,
                fontSize: 12, // Base font size, will be scaled by gizmo
                baseFontSize: 12, // Store base font size for scaling
                textColor: textColor,
                bgColor: null, // Default to transparent
                transparentBg: true, // Default to transparent
                opacity: 100,
                scale: 1,
                pageIndex: currentPreviewPage - 1
            });

            // Add visual gizmo to preview
            const label = text.length > 20 ? `${text.substring(0, 20)}...` : text;
            addOverlayGizmo('text', label, 100, 100, overlayIndex);

            LayerManager.updateLayersList();
            UIControls.closeTextEditor();
        }


        async function convertToWord() {
            if (!currentPdfFile) {
                showModal('No PDF Loaded', 'Please load a PDF file first');
                return;
            }

            try {
                showModal('Processing', 'Converting PDF to Word document...');

                const response = await fetch('/api/convert-to-word', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' }
                });

                if (!response.ok) throw new Error('Conversion failed');

                const blob = await response.blob();
                const url = window.URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `${currentPdfFile.replace('.pdf', '')}.docx`;
                document.body.appendChild(a);
                a.click();
                window.URL.revokeObjectURL(url);
                document.body.removeChild(a);

                closeModal();
                showModal('Success', `Converted "${currentPdfFile}" to Word successfully!`);
            } catch (err) {
                closeModal();
                showModal('Error', `Failed to convert: ${err.message}`);
            }
        }

        async function mergeFiles(position, fileName) {
            if (!currentPdfFile) {
                showModal('Error', 'Please load a PDF file first');
                return;
            }

            // Use the pending merge file
            const file = window.pendingMergeFile;
            if (!file) return;

            try {
                const fileNameLower = file.name.toLowerCase();
                const fileType = file.type.toLowerCase();
                const isPdf = fileNameLower.endsWith('.pdf') || fileType === 'application/pdf';
                const isImage = fileType.startsWith('image/') || fileNameLower.match(/\.(jpg|jpeg|png|gif|bmp|webp)$/);

                if (!isPdf && !isImage) {
                    showModal('Invalid File', 'Please select a PDF or image file');
                    return;
                }

                // If it's an image, convert to PDF via backend first
                if (isImage) {
                    showModal('Processing', 'Converting image to PDF...');

                    const reader = new FileReader();
                    reader.onload = async (e) => {
                        const imageData = e.target.result;

                        try {
                            const response = await fetch('/api/merge-pdfs', {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({
                                    pdfData: imageData,
                                    position: position,
                                    isImage: true
                                })
                            });

                            if (!response.ok) {
                                throw new Error('Failed to merge image');
                            }

                            // Download the merged PDF
                            const blob = await response.blob();

                            // Create a file object from the blob
                            const mergedFile = new File([blob], `${currentPdfFile.replace('.pdf', '')}_merged.pdf`, { type: 'application/pdf' });

                            // Convert blob to base64 and update server's working file
                            const reader2 = new FileReader();
                            reader2.onload = async (e2) => {
                                const pdfData = e2.target.result;
                                try {
                                    await fetch('/api/update-working-file', {
                                        method: 'POST',
                                        headers: { 'Content-Type': 'application/json' },
                                        body: JSON.stringify({ pdfData })
                                    });
                                } catch (err) {
                                    console.warn('Failed to update working file on server:', err);
                                }

                                // Load the merged PDF
                                await loadPDFFile(mergedFile);

                                // Clear merged pages data since PDF is now merged
                                mergedPagesData = [];

                                closeModal();
                                showModal('Success', 'Image merged successfully!', 2000);
                            };
                            reader2.readAsDataURL(blob);
                        } catch (error) {
                            console.error('Merge error:', error);
                            showModal('Error', `Failed to merge image: ${error.message}`);
                        }
                    };
                    reader.readAsDataURL(file);
                    return;
                }

                showModal('Processing', 'Merging PDF pages...');

                // Load the new PDF using PDF.js
                const arrayBuffer = await file.arrayBuffer();
                const newPdfDoc = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
                const newPageCount = newPdfDoc.numPages;

                // Load current PDF if not already loaded
                if (!pdfDocument) {
                    const response = await fetch(`/pdf/${encodeURIComponent(currentPdfFile)}`);
                    const currentArrayBuffer = await response.arrayBuffer();
                    pdfDocument = await pdfjsLib.getDocument({ data: currentArrayBuffer }).promise;
                }

                // Get current state: either existing merged pages or create from thumbnails
                let currentPages = [];
                if (mergedPagesData.length > 0) {
                    // Already have merged pages - use them in current order
                    const thumbnails = document.querySelectorAll('.thumbnail-item');
                    currentPages = Array.from(thumbnails).map((item, idx) => {
                        const pageNum = parseInt(item.dataset.pageNum);
                        const source = item.dataset.source || 'current';
                        const originalPage = parseInt(item.dataset.originalPage) || pageNum;

                        // Find the page info from mergedPagesData
                        const pageInfo = mergedPagesData.find((p, i) => i + 1 === pageNum) ||
                                       { doc: pdfDocument, pageNum: originalPage, source };
                        return pageInfo;
                    });
                } else {
                    // No merged pages yet - use original document
                    for (let i = 1; i <= pdfDocument.numPages; i++) {
                        currentPages.push({ doc: pdfDocument, pageNum: i, source: 'original' });
                    }
                }

                // Create merged pages array
                const mergedPages = [];

                if (position === 'beginning') {
                    // Add new pages first, then current pages
                    for (let i = 1; i <= newPageCount; i++) {
                        mergedPages.push({ doc: newPdfDoc, pageNum: i, source: 'new' });
                    }
                    mergedPages.push(...currentPages);
                } else { // 'end' or default
                    // Add current pages first, then new pages
                    mergedPages.push(...currentPages);
                    for (let i = 1; i <= newPageCount; i++) {
                        mergedPages.push({ doc: newPdfDoc, pageNum: i, source: 'new' });
                    }
                }

                // Generate thumbnails for all pages
                const thumbnailsList = document.getElementById('thumbnailsList');
                thumbnailsList.innerHTML = '';

                for (let i = 0; i < mergedPages.length; i++) {
                    const pageInfo = mergedPages[i];
                    const canvas = document.createElement('canvas');
                    const context = canvas.getContext('2d');

                    // Render PDF page
                    const page = await pageInfo.doc.getPage(pageInfo.pageNum);
                    const viewport = page.getViewport({ scale: 0.3 });
                    canvas.width = viewport.width;
                    canvas.height = viewport.height;
                    await page.render({ canvasContext: context, viewport }).promise;

                    const item = document.createElement('div');
                    item.className = 'thumbnail-item';
                    item.draggable = true;
                    item.dataset.pageNum = i + 1;
                    item.dataset.source = pageInfo.source;
                    item.dataset.originalPage = pageInfo.pageNum;
                    item.innerHTML = `
                        <canvas class="thumbnail-canvas"></canvas>
                        <div class="thumbnail-number">${i + 1}</div>
                    `;

                    if (pageInfo.source === 'new') {
                        item.style.borderColor = '#4CAF50'; // Green border for new pages
                    }

                    const thumbCanvas = item.querySelector('canvas');
                    thumbCanvas.width = canvas.width;
                    thumbCanvas.height = canvas.height;
                    thumbCanvas.getContext('2d').drawImage(canvas, 0, 0);

                    // Click to toggle selection
                    item.addEventListener('click', (e) => {
                        const currentPageNum = parseInt(e.currentTarget.dataset.pageNum);
                        const isSelected = selectedPages.has(currentPageNum);
                        handlePageSelection(currentPageNum, !isSelected);
                    });

                    // Drag events for reordering
                    item.addEventListener('dragstart', handleDragStart);
                    item.addEventListener('dragover', handleDragOver);
                    item.addEventListener('drop', handleDrop);
                    item.addEventListener('dragend', handleDragEnd);

                    thumbnailsList.appendChild(item);
                }

                // Store merged pages data for export
                mergedPagesData = mergedPages;

                // Update page order
                pageOrder = Array.from({ length: mergedPages.length }, (_, i) => i + 1);

                // Store merged state
                window.mergedPdfData = { mergedPages, arrayBuffer };

                closeModal();
                showModal('Success', `Merged ${newPageCount} pages successfully!`);
            } catch (err) {
                closeModal();
                showModal('Error', `Failed to merge: ${err.message}`);
            }
        }

        async function removeSelectedPages() {
            if (selectedPages.size === 0) {
                showModal('No Pages Selected', 'Click pages to select them for removal');
                return;
            }

            if (!currentPdfFile) {
                showModal('No PDF Loaded', 'Please load a PDF first');
                return;
            }

            const pageCount = selectedPages.size;

            showConfirmModal(
                'Remove Pages',
                `Are you sure you want to remove ${pageCount} page(s)?`,
                async () => {
                    try {
                        showModal('Processing', `Removing ${pageCount} page(s)...`);

                        const response = await fetch('/api/remove-pages', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ pages: Array.from(selectedPages) })
                        });

                        if (!response.ok) throw new Error('Remove failed');

                        const blob = await response.blob();

                        // Create a file object from the blob
                        const modifiedFile = new File([blob], `${currentPdfFile.replace('.pdf', '')}_removed.pdf`, { type: 'application/pdf' });

                        // Convert blob to base64 and update server's working file
                        const reader = new FileReader();
                        reader.onload = async (e) => {
                            const pdfData = e.target.result;
                            try {
                                await fetch('/api/update-working-file', {
                                    method: 'POST',
                                    headers: { 'Content-Type': 'application/json' },
                                    body: JSON.stringify({ pdfData })
                                });
                            } catch (err) {
                                console.warn('Failed to update working file on server:', err);
                            }

                            // Load the modified PDF
                            await loadPDFFile(modifiedFile);

                            // Clear selection
                            selectedPages.clear();
                            document.getElementById('removePageBtn').style.display = 'none';

                            closeModal();
                            showModal('Success', `Removed ${pageCount} page(s) successfully!`, 2000);
                        };
                        reader.readAsDataURL(blob);
                    } catch (err) {
                        closeModal();
                        showModal('Error', `Failed to remove pages: ${err.message}`);
                    }
                }
            );
        }

        function shareApp() {
            window.open('https://twitter.com/intent/tweet?text=Check%20out%20PDFile%20%E2%80%93%20Free%20PDF%20utility%20toolkit!%20pdfile.co', '_blank');
        }


        // ===== OVERLAY GIZMO =====
        function addOverlayGizmo(type, label, x, y, overlayIndex) {
            const canvasWrapper = document.querySelector('.canvas-wrapper');
            if (!canvasWrapper) return; // Canvas not loaded yet

            const overlay = AppState.getOverlay(overlayIndex);

            // Create gizmo element
            const gizmo = document.createElement('div');
            gizmo.className = 'overlay-gizmo';
            gizmo.style.left = x + 'px';
            gizmo.style.top = y + 'px';
            gizmo.style.opacity = (overlay.opacity || 100) / 100;
            gizmo.dataset.overlayIndex = overlayIndex;

            // Set gizmo size based on overlay dimensions
            if (overlay && (type === 'image' || type === 'signature')) {
                gizmo.style.width = (overlay.width || 120) + 'px';
                gizmo.style.height = (overlay.height || 60) + 'px';
            }

            // Build inner HTML based on type
            let content = '';
            if (type === 'image' || type === 'signature') {
                // Show image preview
                content = overlay && overlay.imageData
                    ? `<img src="${overlay.imageData}" alt="${label}">`
                    : `<div class="overlay-gizmo-text">${label}</div>`;
            } else {
                // Show text label for date/text overlays with colors
                const textColor = overlay.textColor || '#000000';
                const bgColor = overlay.transparentBg ? 'transparent' : (overlay.bgColor || '#ffffff');
                const fontSize = overlay.fontSize || 12;
                content = `<div class="overlay-gizmo-text" style="color: ${textColor}; background-color: ${bgColor}; font-size: ${fontSize}px;">${label}</div>`;
            }

            // Transparency control removed - now in overlays panel
            gizmo.innerHTML = `
                <div class="overlay-gizmo-label">${label}</div>
                <div class="overlay-gizmo-handle resize-handle" data-action="resize" title="Drag to resize"></div>
                <div class="overlay-gizmo-rotate" data-action="rotate" title="Drag to rotate"></div>
                <button class="overlay-gizmo-delete" onclick="removeOverlay(${overlayIndex})" title="Remove"></button>
                ${content}
            `;

            // Handle drag, resize, and rotate
            let action = null;
            let startX, startY, initialLeft, initialTop, initialWidth, initialHeight;
            let centerX, centerY, initialAngle;

            gizmo.addEventListener('mousedown', (e) => {
                if (e.target.classList.contains('overlay-gizmo-delete')) return;

                const targetAction = e.target.dataset.action;

                // If no special action, select this overlay (unless starting drag/resize/rotate)
                if (!targetAction) {
                    SelectionManager.selectOverlay(overlayIndex);
                }

                if (targetAction === 'resize') {
                    action = 'resize';
                    startX = e.clientX;
                    startY = e.clientY;
                    initialWidth = gizmo.offsetWidth;
                    initialHeight = gizmo.offsetHeight;
                } else if (targetAction === 'rotate') {
                    action = 'rotate';
                    const rect = gizmo.getBoundingClientRect();
                    centerX = rect.left + rect.width / 2;
                    centerY = rect.top + rect.height / 2;
                    initialAngle = Math.atan2(e.clientY - centerY, e.clientX - centerX) * (180 / Math.PI);
                    const currentRotation = AppState.getOverlay(overlayIndex)?.rotation || 0;
                    initialAngle = initialAngle - currentRotation;
                } else {
                    action = 'move';
                    startX = e.clientX;
                    startY = e.clientY;
                    initialLeft = parseInt(gizmo.style.left) || 0;
                    initialTop = parseInt(gizmo.style.top) || 0;
                    gizmo.style.cursor = 'grabbing';
                }
                e.preventDefault();
                e.stopPropagation();
            });

            document.addEventListener('mousemove', (e) => {
                if (!action) return;

                const index = parseInt(gizmo.dataset.overlayIndex);

                if (action === 'move') {
                    const deltaX = e.clientX - startX;
                    const deltaY = e.clientY - startY;

                    const newLeft = Math.max(0, initialLeft + deltaX);
                    const newTop = Math.max(0, initialTop + deltaY);

                    gizmo.style.left = newLeft + 'px';
                    gizmo.style.top = newTop + 'px';

                    AppState.updateOverlay(index, { x: newLeft, y: newTop });
                } else if (action === 'resize') {
                    const deltaX = e.clientX - startX;
                    const deltaY = e.clientY - startY;

                    const newWidth = Math.max(30, initialWidth + deltaX);
                    const newHeight = Math.max(20, initialHeight + deltaY);

                    gizmo.style.width = newWidth + 'px';
                    gizmo.style.height = newHeight + 'px';

                    const currentOverlay = AppState.getOverlay(index);
                    if (currentOverlay) {
                        const updates = { width: newWidth, height: newHeight };

                        // Scale font size for text overlays
                        if (currentOverlay.type === 'date' || currentOverlay.type === 'text') {
                            const scale = newWidth / initialWidth;
                            const baseFontSize = currentOverlay.baseFontSize || 12;
                            const newFontSize = Math.max(8, Math.round(baseFontSize * scale));
                            updates.fontSize = newFontSize;

                            // Update visual text size in gizmo
                            const textElement = gizmo.querySelector('.overlay-gizmo-text');
                            if (textElement) {
                                textElement.style.fontSize = newFontSize + 'px';
                            }

                            // Store the initial base font size
                            if (!currentOverlay.baseFontSize) {
                                updates.baseFontSize = 12;
                            }
                        }

                        AppState.updateOverlay(index, updates);
                    }
                } else if (action === 'rotate') {
                    const currentAngle = Math.atan2(e.clientY - centerY, e.clientX - centerX) * (180 / Math.PI);
                    const rotation = currentAngle - initialAngle;

                    gizmo.style.transform = `rotate(${rotation}deg)`;

                    AppState.updateOverlay(index, { rotation });
                }
            });

            document.addEventListener('mouseup', () => {
                if (action) {
                    action = null;
                    gizmo.style.cursor = 'move';
                }
            });

            canvasWrapper.appendChild(gizmo);

            // Initialize Lucide icons in the gizmo
            lucide.createIcons();
        }

        function removeOverlay(index) {
            const overlay = AppState.getOverlay(index);
            if (!overlay) return;

            const label = overlay.dateText || overlay.type || 'overlay';

            showConfirmModal(
                'Remove Overlay',
                `Remove this ${overlay.type === 'signature' ? 'signature' : overlay.type}?`,
                () => {
                    AppState.removeOverlay(index);

                    // Deselect if this was selected
                    const selectedIndex = AppState.getSelectedIndex();
                    if (selectedIndex === index) {
                        SelectionManager.deselectOverlay();
                    } else if (selectedIndex > index) {
                        AppState.setSelectedIndex(selectedIndex - 1);
                    }

                    // Remove all gizmos and recreate them with updated indices for current page
                    updateGizmosForPage(currentPreviewPage);
                    LayerManager.updateLayersList();
                }
            );
        }

        // ===== LAYERS MANAGEMENT =====
        // Old functions removed - now using LayerManager and SelectionManager modules

        // ===== EXPORT PDF =====
        async function exportPDF() {
            if (!currentPdfFile) return;

            const exportBtn = document.getElementById('exportBtn');
            if (!exportBtn) return;

            const originalHtml = exportBtn.innerHTML;

            try {
                // Show subtle processing indicator instead of modal
                exportBtn.innerHTML = '<i data-lucide="loader" style="animation: spin 1s linear infinite;"></i>';
                exportBtn.disabled = true;

                // Build the current page order from thumbnails
                const thumbnails = Array.from(document.querySelectorAll('.thumbnail-item'));
                const pageOrder = thumbnails.map((item, idx) => ({
                    pageNum: parseInt(item.dataset.originalPage) || parseInt(item.dataset.pageNum),
                    source: item.dataset.source || 'original',
                    displayOrder: idx + 1
                }));

                // Check if pages have been reordered (compare to natural order)
                const hasReordering = pageOrder.some((item, idx) => item.pageNum !== idx + 1);

                // Debug logging
                console.log('Export PDF - Page Order:', pageOrder);
                console.log('Export PDF - hasReordering:', hasReordering);

                // Check if we have merged pages or page reordering or overlays
                const hasMergedPages = mergedPagesData.length > 0;
                const hasOverlays = pendingOverlays.length > 0;

                // If no changes, just download the current PDF
                if (!hasMergedPages && !hasOverlays && !hasReordering) {
                    const response = await fetch(`/pdf/${encodeURIComponent(currentPdfFile)}`);
                    const blob = await response.blob();
                    const url = window.URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = currentPdfFile;
                    document.body.appendChild(a);
                    a.click();
                    window.URL.revokeObjectURL(url);
                    document.body.removeChild(a);

                    exportBtn.innerHTML = originalHtml;
                    exportBtn.disabled = false;
                    lucide.createIcons();
                    return;
                }

                // Send request with both page order and overlays
                const response = await fetch('/api/export-pdf', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        hasMergedPages,
                        hasReordering,
                        pageOrder,
                        overlays: pendingOverlays,
                        mergedPagesData: hasMergedPages ? mergedPagesData : null
                    })
                });

                if (!response.ok) {
                    const error = await response.json();
                    throw new Error(error.error || 'Failed to export PDF');
                }

                const blob = await response.blob();
                const url = window.URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                const suffix = hasOverlays ? '_abused' : '_modified';
                a.download = `${currentPdfFile.replace('.pdf', '')}${suffix}.pdf`;
                document.body.appendChild(a);
                a.click();
                window.URL.revokeObjectURL(url);
                document.body.removeChild(a);

                // Clear overlays
                pendingOverlays = [];

                // Remove gizmos
                document.querySelectorAll('.overlay-gizmo').forEach(g => g.remove());

                // Restore button
                exportBtn.innerHTML = originalHtml;
                exportBtn.disabled = false;
                lucide.createIcons();

            } catch (err) {
                // Restore button on error
                exportBtn.innerHTML = originalHtml;
                exportBtn.disabled = false;
                lucide.createIcons();

                showModal('Error', `Failed to export: ${err.message}`);
                console.error('Export error:', err);
            }
        }

        // ===== IMAGE DROP HANDLER =====
        async function handleImageDrop(file) {
            if (!currentPdfFile) {
                showModal('No PDF Loaded', 'Please load a PDF file first');
                return;
            }

            try {
                const reader = new FileReader();
                reader.onload = async (event) => {
                    const imageData = event.target.result;

                    // Create an image element to get dimensions
                    const img = new Image();
                    img.onload = () => {
                        // Get canvas dimensions for centering
                        const canvas = document.getElementById('pdfCanvas');
                        const canvasWidth = canvas?.width || 800;
                        const canvasHeight = canvas?.height || 1000;

                        // Determine if image is large enough to be used as a page
                        const isLargeImage = img.width >= 300 || img.height >= 300;

                        let width, height, x, y;

                        if (isLargeImage) {
                            // Calculate dimensions to fit the page while maintaining aspect ratio
                            const pageAspect = canvasWidth / canvasHeight;
                            const imgAspect = img.width / img.height;

                            if (imgAspect > pageAspect) {
                                // Image is wider - fit to width
                                width = canvasWidth * 0.9;
                                height = width / imgAspect;
                            } else {
                                // Image is taller - fit to height
                                height = canvasHeight * 0.9;
                                width = height * imgAspect;
                            }

                            // Center on page
                            x = (canvasWidth - width) / 2;
                            y = (canvasHeight - height) / 2;
                        } else {
                            // Small image - use original size and center
                            width = img.width;
                            height = img.height;
                            x = (canvasWidth - width) / 2;
                            y = (canvasHeight - height) / 2;
                        }

                        // Add to recent images
                        addToRecentImages(file.name, imageData);

                        // Add to pending overlays
                        const overlayIndex = pendingOverlays.length;

                        pendingOverlays.push({
                            type: 'image',
                            imageData: imageData,
                            x: Math.max(0, x),
                            y: Math.max(0, y),
                            width: width,
                            height: height,
                            opacity: 100,
                            removeBackground: false,
                            pageIndex: currentPreviewPage - 1
                        });

                        // Add visual gizmo to preview
                        const label = isLargeImage ? 'Image (Full Page)' : 'Image';
                        addOverlayGizmo('image', label, Math.max(0, x), Math.max(0, y), overlayIndex);
                        updateLayersList();

                        console.log(`Image dropped: ${file.name} (${img.width}x${img.height}) - ${isLargeImage ? 'large' : 'small'} - centered at (${x}, ${y})`);
                    };

                    img.onerror = () => {
                        showModal('Error', 'Failed to load image');
                    };

                    img.src = imageData;
                };

                reader.onerror = () => {
                    showModal('Error', 'Failed to read image file');
                };

                reader.readAsDataURL(file);
            } catch (err) {
                showModal('Error', `Failed to process image: ${err.message}`);
            }
        }

        // ===== INITIALIZATION =====
        // Initialize window size and position
        (function initWindow() {
            const html = document.documentElement;
            const w = parseInt(html.getAttribute('data-width')) || 700;
            const h = parseInt(html.getAttribute('data-height')) || 590;

            // Center window on available screen
            const x = Math.round((screen.availWidth - w) / 2) + (screen.availLeft || 0);
            const y = Math.round((screen.availHeight - h) / 2) + (screen.availTop || 0);

            if (typeof window.moveTo === 'function') {
                window.moveTo(x, y);
            }
            if (typeof window.resizeTo === 'function') {
                window.resizeTo(w, h);
            }

            // Reset zoom
            html.style.zoom = '100%';
        })();

        document.addEventListener('contextmenu', e => e.preventDefault());
        // Initialize components
        let datePicker, textColorPicker, bgColorPicker;
        let selectedTextColor = '#000000';
        let selectedBgColor = '#ffffff';

        document.addEventListener('DOMContentLoaded', () => {
            loadInitialPDF();
            lucide.createIcons();

            // Load recent images from localStorage
            loadRecentImages();

            // Set up file input change listener
            document.getElementById('imageFile').addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (!file || !currentPdfFile) return;

                // Read file as base64
                const reader = new FileReader();
                reader.onload = (event) => {
                    const imageData = event.target.result;

                    // Add to recent images
                    addToRecentImages(file.name, imageData);

                    // Add to pending overlays
                    const overlayIndex = AppState.getOverlays().length;

                    const overlayData = {
                        type: 'image',
                        imageData: imageData,
                        x: 100,
                        y: 100,
                        width: 150,
                        height: 150,
                        opacity: 100,
                        removeBackground: false,
                        pageIndex: currentPreviewPage - 1
                    };

                    AppState.addOverlay(overlayData);

                    // Add visual gizmo to preview
                    addOverlayGizmo('image', 'Image', 100, 100, overlayIndex);
                    LayerManager.updateLayersList();

                    // Clear file input
                    e.target.value = '';
                };
                reader.readAsDataURL(file);
            });

            // Initialize Flatpickr date picker (hidden input)
            const hiddenDateInput = document.createElement('input');
            hiddenDateInput.type = 'text';
            hiddenDateInput.style.display = 'none';
            document.body.appendChild(hiddenDateInput);

            datePicker = flatpickr(hiddenDateInput, {
                defaultDate: 'today',
                dateFormat: 'Y-m-d',
                allowInput: false,
                theme: 'dark',
                positionElement: document.getElementById('textContent'), // Position relative to text input
                position: 'below', // Show below the input
                onReady: function(selectedDates, dateStr, instance) {
                    const todayBtn = document.createElement('button');
                    todayBtn.textContent = 'Today';
                    todayBtn.className = 'flatpickr-today-button';
                    todayBtn.style.cssText = 'margin: 8px; padding: 6px 12px; background: #7fa5df; color: #fff; border: none; border-radius: 4px; cursor: pointer; font-size: 12px;';
                    todayBtn.onclick = function(e) {
                        e.preventDefault();
                        instance.setDate(new Date(), true);
                        instance.close(); // Close the picker after applying today's date
                    };
                    instance.calendarContainer.appendChild(todayBtn);
                },
                onChange: function(selectedDates, dateStr, instance) {
                    if (selectedDates.length > 0) {
                        lastPickedDate = selectedDates[0];
                        const textInput = document.getElementById('textContent');
                        textInput.value = formatDateByFormat(lastPickedDate, currentDateFormat);

                        // Mark as date content and show format toggle button
                        textContentIsDate = true;
                        document.getElementById('dateFormatBtn').style.display = 'block';

                        // Enable Add Text button
                        updateAddTextButtonState();
                    }
                }
            });

            // Add listener to text content input
            const textContentInput = document.getElementById('textContent');
            textContentInput.addEventListener('input', () => {
                textContentIsDate = false; // User is typing, not from date picker
                onTextContentChange();
            });

            // Initialize Pickr color pickers
            textColorPicker = Pickr.create({
                el: '#textColorPicker',
                theme: 'nano',
                default: '#000000',
                swatches: [
                    '#000000', '#ffffff', '#ff0000', '#00ff00', '#0000ff',
                    '#ffff00', '#ff00ff', '#00ffff'
                ],
                components: {
                    preview: true,
                    opacity: false,
                    hue: true,
                    palette: true,
                    interaction: {
                        hex: true,
                        input: true,
                        save: false,
                        clear: false,
                        cancel: false
                    }
                },
                useAsButton: false,
                inline: false,
                autoReposition: true
            });

            // Initialize with default color
            textColorPicker.on('init', (instance) => {
                selectedTextColor = instance.getColor().toHEXA().toString();
            });

            // Update color in real-time as user selects
            textColorPicker.on('change', (color) => {
                const hexColor = color.toHEXA().toString();
                UIControls.updateLayerColor(hexColor, false);
            });

            bgColorPicker = Pickr.create({
                el: '#bgColorPicker',
                theme: 'nano',
                default: '#ffffff',
                swatches: [
                    '#ffffff', '#000000', '#ffff00', '#00ffff',
                    '#ff00ff', '#c0c0c0', '#808080'
                ],
                components: {
                    preview: true,
                    opacity: false,
                    hue: true,
                    palette: true,
                    interaction: {
                        hex: true,
                        input: true,
                        save: false,
                        clear: false,
                        cancel: false
                    }
                },
                useAsButton: false,
                inline: false,
                autoReposition: true
            });

            // Initialize with default color
            bgColorPicker.on('init', (instance) => {
                selectedBgColor = instance.getColor().toHEXA().toString();
            });

            // Update color in real-time as user selects
            bgColorPicker.on('change', (color) => {
                const hexColor = color.toHEXA().toString();
                UIControls.updateLayerColor(hexColor, true);
            });

            // Set up drag & drop for PDF, image, and document files
            const thumbnailsPanel = document.getElementById('thumbnailsPanel');
            const previewArea = document.getElementById('previewArea');

            // Thumbnails panel - always merge as page
            thumbnailsPanel.addEventListener('dragover', (e) => {
                e.preventDefault();
                e.stopPropagation();
                thumbnailsPanel.style.opacity = '0.7';
                thumbnailsPanel.style.backgroundColor = 'rgba(127, 165, 223, 0.1)';
            });

            thumbnailsPanel.addEventListener('dragleave', (e) => {
                e.preventDefault();
                e.stopPropagation();
                thumbnailsPanel.style.opacity = '';
                thumbnailsPanel.style.backgroundColor = '';
            });

            thumbnailsPanel.addEventListener('drop', async (e) => {
                e.preventDefault();
                e.stopPropagation();
                thumbnailsPanel.style.opacity = '';
                thumbnailsPanel.style.backgroundColor = '';

                const files = e.dataTransfer.files;
                if (files.length > 0) {
                    const file = files[0];
                    const fileType = file.type.toLowerCase();
                    const fileName = file.name.toLowerCase();

                    const isPdf = fileType === 'application/pdf' || fileName.endsWith('.pdf');
                    const isImage = fileType.startsWith('image/') || fileName.match(/\.(jpg|jpeg|png|gif|bmp|webp)$/);

                    if (isPdf || isImage) {
                        // Merge as page
                        window.pendingMergeFile = file;
                        showMergeDialog(file);
                    } else {
                        showModal('Invalid File', 'Please drop a PDF or image file');
                    }
                }
            });

            // Preview area - images as overlay, PDFs as merge
            previewArea.addEventListener('dragover', (e) => {
                e.preventDefault();
                e.stopPropagation();
                previewArea.style.opacity = '0.7';
                previewArea.style.backgroundColor = 'rgba(127, 165, 223, 0.1)';
            });

            previewArea.addEventListener('dragleave', (e) => {
                e.preventDefault();
                e.stopPropagation();
                previewArea.style.opacity = '';
                previewArea.style.backgroundColor = '';
            });

            previewArea.addEventListener('drop', async (e) => {
                e.preventDefault();
                e.stopPropagation();
                previewArea.style.opacity = '';
                previewArea.style.backgroundColor = '';

                const files = e.dataTransfer.files;
                if (files.length > 0) {
                    const file = files[0];
                    const fileType = file.type.toLowerCase();
                    const fileName = file.name.toLowerCase();

                    const isPdf = fileType === 'application/pdf' || fileName.endsWith('.pdf');
                    const isImage = fileType.startsWith('image/') || fileName.match(/\.(jpg|jpeg|png|gif|bmp|webp)$/);

                    if (isPdf) {
                        // Merge as page
                        window.pendingMergeFile = file;
                        showMergeDialog(file);
                    } else if (isImage) {
                        // Add as overlay
                        await handleImageDrop(file);
                    } else {
                        showModal('Invalid File', 'Please drop a PDF or image file');
                    }
                }
            });
        });
    </script>
</body>
</html>
